<template>
  <div class="dental-viewer">
    <!-- Loading Overlay -->
    <LoadingOverlay 
      :isLoading="threeJSManager.isLoading.value"
      :loadingMessage="threeJSManager.loadingMessage.value"
    />
    
    <AppHeader 
      title="Aligner" 
      description="3D dental model viewer"
      :clickable="true"
      @logoClick="handleLogoClick"
    >
      <template #center>
        <TopToolbar
          :dentalModel="dentalModel"
          :selectedSegments="segmentManager.selectedSegments.value"
          :currentMode="currentMode"
          :isLoading="threeJSManager.isLoading.value"
          :interactionModes="interactionModes"
          @setInteractionMode="setInteractionMode"
          @setLassoMode="setLassoMode"
        />
      </template>
      <template #actions>
        <button @click="handleLogout" class="logout-btn">
          <Icon name="log-out" :size="16" color="currentColor" />
          Logout
        </button>
      </template>
    </AppHeader>

    <!-- Background Status Indicator -->
    <BackgroundStatusIndicator
      :status="backgroundSegmentationStatus"
      @dismiss="dismissBackgroundStatus"
    />

    <!-- Main Content Area -->
    <div
      class="main-content"
      :class="{ 'treatment-fullscreen': isTreatmentPlanFullScreen }"
    >
      <LeftSidebar
        v-show="!isTreatmentPlanFullScreen"
        :dentalModel="dentalModel"
        :selectedSegments="segmentManager.selectedSegments.value"
        :currentTreatmentPlan="currentTreatmentPlan"
        :intersectionResults="segmentManager.intersectionResults.value"
        @toggleOriginalMesh="toggleOriginalMesh"
        @toggleAllSegments="toggleAllSegments"
        @toggleSegmentSelection="segmentManager.toggleSegmentSelection"
        @changeSegmentColor="segmentManager.changeSegmentColor"
        @resetIndividualPosition="segmentManager.resetIndividualPosition"
        @toggleSegmentVisibility="segmentManager.toggleSegmentVisibility"
        @deleteSegment="deleteSegment"
        @planCreated="handlePlanCreated"
        @planUpdated="handlePlanUpdated"
        @stepChanged="handleStepChanged"
        @treatmentPlanFullScreen="handleTreatmentPlanFullScreen"
      />

      <ViewportArea
        v-show="!isTreatmentPlanFullScreen"
        ref="viewportRef"
        :dentalModel="dentalModel"
        :currentMode="currentMode"
        :isLoading="threeJSManager.isLoading.value"
        :loadingMessage="threeJSManager.loadingMessage.value"
        :selectedSegments="segmentManager.selectedSegments.value"
        :totalMovementDistance="segmentManager.totalMovementDistance.value"
        @setViewPreset="setViewPreset"
        @startDirectionalMove="startDirectionalMove"
        @stopDirectionalMove="stopDirectionalMove"
      />
    </div>

    <!-- Full-screen Treatment Plan -->
    <div v-if="isTreatmentPlanFullScreen" class="fullscreen-treatment-plan">
      <TreatmentPlanPanel
        :segments="dentalModel?.segments || []"
        :isVisible="true"
        :isFullScreenMode="true"
        :currentTreatmentPlan="currentTreatmentPlan"
        @planCreated="handlePlanCreated"
        @planUpdated="handlePlanUpdated"
        @stepChanged="handleStepChanged"
        @toggleFullScreen="handleTreatmentPlanFullScreen"
      />

      <!-- Intersection Panel -->
      <IntersectionPanel
        :intersectionResults="segmentManager.intersectionResults.value"
        :statistics="segmentManager.intersectionStatistics.value"
        :showNoIntersections="true"
        @highlight="handleIntersectionHighlight"
        @isolate="handleIntersectionIsolate"
        @clear-visualizations="handleClearIntersectionVisualizations"
        @export-data="handleExportIntersectionData"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, shallowRef, computed } from "vue";
import { useRoute, useRouter } from "vue-router";
import { useThreeJS } from "../composables/useThreeJS";
import { useThreeJSManager } from "../composables/useThreeJSManager";
import { useSegmentManager } from "../composables/useSegmentManager";
import { useCameraControls } from "../composables/useCameraControls";
import { useDirectionalMovement } from "../composables/useDirectionalMovement";
import { useGeometryManipulation } from "../composables/useGeometryManipulation";
import { FileHandlerService } from "../services/FileHandlerService";
import { SegmentationService } from "../services/SegmentationService";
import type {
  DentalModel,
  InteractionMode,
  OrthodonticTreatmentPlan,
  ToothSegment,
} from "../types/dental";
import type {
  EnhancedLassoService,
  LassoMode,
  LassoOperationResult,
} from "../services/EnhancedLassoService";
import AppHeader from "./AppHeader.vue";
import TopToolbar from "./TopToolbar.vue";
import LeftSidebar from "./LeftSidebar.vue";
import ViewportArea from "./ViewportArea.vue";
import BackgroundStatusIndicator from "./BackgroundStatusIndicator.vue";
import TreatmentPlanPanel from "./TreatmentPlanPanel.vue";
import IntersectionPanel from "./IntersectionPanel.vue";
import LoadingOverlay from "./LoadingOverlay.vue";
import Icon from "./Icon.vue";

// Use the lazy loading composable
const { loadThreeJS, loadServices } = useThreeJS();

// Get route params
const route = useRoute();
const router = useRouter();
const caseId = route.params.caseId as string;

// Initialize composables
const threeJSManager = useThreeJSManager();
const segmentManager = useSegmentManager();
const cameraControls = useCameraControls();
const directionalMovement = useDirectionalMovement();
const geometryManipulation = useGeometryManipulation();

// Refs
const viewportRef = ref<typeof ViewportArea>();

// Canvas container reference
const canvasContainer = computed(
  () => viewportRef.value?.canvasContainer as HTMLDivElement
);

// Services - will be initialized after lazy loading
let fileHandlerService: FileHandlerService | null = null;
let segmentationService: SegmentationService | null = null;
let enhancedLassoService: EnhancedLassoService | null = null;
let THREE: any = null;

// Enhanced Lasso state
const currentLassoMode = ref<LassoMode>("create");

// Reactive state
const dentalModel = shallowRef<DentalModel | null>(null);
const currentMode = ref<InteractionMode["mode"]>("lasso");
const backgroundSegmentationStatus = ref<{
  isRunning: boolean;
  message: string;
  progress?: number;
}>({
  isRunning: false,
  message: "",
  progress: undefined,
});
const isTreatmentPlanFullScreen = ref(false);
const currentTreatmentPlan = ref<OrthodonticTreatmentPlan | null>(null);

// User data
const user = ref(null);

const interactionModes: InteractionMode["mode"][] = ["lasso", "pan"];

onMounted(async () => {
  // Load user data
  const userData = localStorage.getItem('user')
  if (userData) {
    user.value = JSON.parse(userData)
  }

  await initializeApp();
});

async function initializeApp() {
  try {
    threeJSManager.isLoading.value = true;
    threeJSManager.loadingMessage.value = "Loading 3D Engine...";

    // Load Three.js and services
    const { THREE: ThreeJS, BVH } = await loadThreeJS();
    THREE = ThreeJS; // Store THREE globally for this component

    const {
      STLLoaderService: STLLoader,
      OBJLoaderService: OBJLoader,
      PLYLoaderService: PLYLoader,
      GLTFLoaderService: GLTFLoader,
    } = await loadServices();

    // Add BVH extensions to THREE.js
    THREE.BufferGeometry.prototype.computeBoundsTree = BVH.computeBoundsTree;
    THREE.BufferGeometry.prototype.disposeBoundsTree = BVH.disposeBoundsTree;
    THREE.Mesh.prototype.raycast = BVH.acceleratedRaycast;

    // Initialize Three.js scene
    const threeJSResult = threeJSManager.initThreeJS(
      canvasContainer.value!,
      THREE
    );
    if (!threeJSResult) {
      throw new Error("Failed to initialize Three.js");
    }

    const { scene, camera, renderer } = threeJSResult;

    // Initialize services
    fileHandlerService = new FileHandlerService(
      new STLLoader(),
      new OBJLoader(),
      new PLYLoader(),
      new GLTFLoader(),
      scene
    );

    const { BackendService } = await import("../services/BackendService");
    const backendService = new BackendService("http://localhost:8000", THREE);
    segmentationService = new SegmentationService(backendService, scene, THREE);

    // Initialize intersection detection
    segmentManager.initializeIntersectionDetection(scene);

    // Setup event listeners
    if (renderer?.domElement) {
      // Create lasso handlers object
      const lassoHandlers = {
        handleLassoMouseDown,
        handleLassoMouseMove,
        handleLassoMouseUp,
      };

      cameraControls.setupEventListeners(
        renderer.domElement,
        camera,
        renderer,
        currentMode,
        THREE,
        lassoHandlers
      );
      threeJSManager.setupResizeObserver(canvasContainer.value!);
    }

    // Initialize Enhanced Lasso Service
    await initializeEnhancedLasso(renderer, camera, scene);

    // Load case data and STL file
    await loadCaseData();

    threeJSManager.isLoading.value = false;
  } catch (error) {
    console.error("Failed to initialize app:", error);
    threeJSManager.loadingMessage.value = "Failed to load 3D engine";
  }
}

// Load case data and STL file
async function loadCaseData() {
  try {
    if (!caseId) {
      console.error("No case ID provided");
      return;
    }

    threeJSManager.loadingMessage.value = "Loading case data...";
    
    // Get auth token
    const token = localStorage.getItem('authToken');
    if (!token) {
      throw new Error("No authentication token found");
    }

    // Fetch case data from backend
    const response = await fetch(`http://localhost:3001/api/cases/${caseId}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch case: ${response.statusText}`);
    }

    const responseData = await response.json();
    const caseData = responseData.case; // Extract case data from response
    console.log("Case data loaded:", caseData);

    // Load the STL file from id/raw endpoint
    threeJSManager.loadingMessage.value = "Loading STL file...";
    
    const fileUrl = `http://localhost:3001/api/cases/${caseId}/raw`;
    console.log("Loading STL file from:", fileUrl);
    
    // Get auth token
    const authToken = localStorage.getItem('authToken') || undefined;
    
    // Load the STL file using the file handler service
    const loadedModel = await fileHandlerService?.loadSTLFile(fileUrl, authToken);
      
      if (loadedModel) {
        // Compute bounding box for the loaded mesh
        loadedModel.geometry.computeBoundingBox();
        const boundingBox = {
          min: loadedModel.geometry.boundingBox.min.clone(),
          max: loadedModel.geometry.boundingBox.max.clone()
        };
        
        console.log("Mesh bounding box:", boundingBox);
        
        // Ensure the mesh is visible and has proper material
        loadedModel.visible = true;
        if (!loadedModel.material) {
          loadedModel.material = new THREE.MeshStandardMaterial({ 
            color: 0xcccccc,
            metalness: 0.1,
            roughness: 0.8
          });
        }
        
        // Create dental model structure
        dentalModel.value = {
          originalMesh: loadedModel,
          segments: [],
          boundingBox: boundingBox
        };
        
        // Store case metadata separately if needed
        console.log("Case metadata:", {
          caseId: caseData.id,
          caseName: caseData.case_name,
          fileName: caseData.file_name,
          uploadedAt: caseData.created_at
        });
        
        console.log("Dental model loaded successfully:", dentalModel.value);
        
        // Load existing segments from backend
        await loadExistingSegments();
        
        // Focus camera on the loaded model
        if (dentalModel.value) {
          console.log("Focusing camera on model...");
          threeJSManager.focusOnModel(dentalModel.value);
          
          // Debug scene and camera
          const scene = threeJSManager.getScene();
          const camera = threeJSManager.getCamera();
          const renderer = threeJSManager.getRenderer();
          
          console.log("Scene children count:", scene.children.length);
          console.log("Camera position:", camera.position);
          console.log("Camera target:", camera.getWorldDirection(new THREE.Vector3()));
          
          // Force a render update
          if (renderer) {
            console.log("Forcing render update...");
            renderer.render(scene, camera);
          }
        }
      } else {
        throw new Error("Failed to load STL file");
      }
  } catch (error) {
    console.error("Failed to load case data:", error);
    threeJSManager.loadingMessage.value = "Failed to load case data";
  }
}

// Event handlers and functions
function setInteractionMode(mode: InteractionMode["mode"]) {
  // Clean up any active enhanced lasso selection when changing modes
  if (currentMode.value === "lasso" && enhancedLassoService?.isLassoActive()) {
    enhancedLassoService.cancelLasso();
  }

  currentMode.value = mode;
  console.log(`Interaction mode changed to: ${mode}`);

  // Set appropriate cursor for the new mode
  const renderer = threeJSManager.getRenderer();
  if (renderer?.domElement) {
    const cursorMap = {
      lasso: "crosshair",
      pan: "grab",
    };
    renderer.domElement.style.cursor = cursorMap[mode] || "default";
  }
}

function setViewPreset(
  view: "top" | "bottom" | "front" | "back" | "left" | "right"
) {
  if (!dentalModel.value) return;
  threeJSManager.setViewPreset(view, dentalModel.value);
}

// Enhanced Lasso Handlers
function setLassoMode(mode: LassoMode) {
  currentLassoMode.value = mode;
  console.log(`Lasso mode set to: ${mode}`);
}

// Lasso Mouse Event Handlers
function handleLassoMouseDown(event: MouseEvent) {
  if (
    currentMode.value !== "lasso" ||
    !enhancedLassoService ||
    !dentalModel.value
  )
    return;

  // Don't start lasso if modifier keys are held (for rotation/pan)
  if (event.metaKey || event.ctrlKey) return;

  const renderer = threeJSManager.getRenderer();
  if (!renderer) return;

  const rect = renderer.domElement.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;

  const targetSegmentId =
    segmentManager.selectedSegments.value.length > 0
      ? segmentManager.selectedSegments.value[0].id
      : undefined;

  enhancedLassoService.startLasso(
    currentLassoMode.value,
    { x, y },
    targetSegmentId
  );

  console.log(
    `Started enhanced lasso selection in ${currentLassoMode.value} mode`
  );
}

function handleLassoMouseMove(event: MouseEvent) {
  if (
    currentMode.value !== "lasso" ||
    !enhancedLassoService ||
    !enhancedLassoService.isLassoActive()
  )
    return;

  // Don't update lasso if modifier keys are held (for rotation/pan)
  if (event.metaKey || event.ctrlKey) return;

  const renderer = threeJSManager.getRenderer();
  if (!renderer) return;

  const rect = renderer.domElement.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;

  enhancedLassoService.updateLasso({ x, y });
}

function handleLassoMouseUp(_event: MouseEvent) {
  if (
    currentMode.value !== "lasso" ||
    !enhancedLassoService ||
    !enhancedLassoService.isLassoActive()
  )
    return;

  const result = enhancedLassoService.finishLasso(dentalModel.value!);

  if (result) {
    handleLassoOperationResult(result);
  }

  console.log("Finalized enhanced lasso selection");
}

function handleLassoOperationResult(result: LassoOperationResult) {
  switch (result.mode) {
    case "create":
      handleLassoCreateSegment(result.selectedVertices);
      break;
    case "select":
      handleLassoSelectSegments(result.affectedSegments);
      break;
    case "add":
      handleLassoAddToSegment(result.selectedVertices, result.targetSegmentId);
      break;
    case "subtract":
      handleLassoSubtractFromSegment(
        result.selectedVertices,
        result.targetSegmentId
      );
      break;
  }
}

async function handleLassoCreateSegment(selectedVertices: number[]) {
  if (!dentalModel.value?.originalMesh || selectedVertices.length === 0) {
    alert("No vertices found inside lasso area.");
    return;
  }

  try {
    threeJSManager.isLoading.value = true;
    threeJSManager.loadingMessage.value = "Creating segment...";

    const newSegment = await geometryManipulation.createSegmentFromVertices(
      selectedVertices,
      dentalModel.value.originalMesh,
      dentalModel.value,
      THREE
    );

    if (newSegment) {
      dentalModel.value.segments.push(newSegment);
      const scene = threeJSManager.getScene();
      if (scene) {
        scene.add(newSegment.mesh);
      }
      dentalModel.value = { ...dentalModel.value };

      // Keep original mesh visible for more segmentations
      dentalModel.value.originalMesh.visible = true;
      if (scene && !scene.children.includes(dentalModel.value.originalMesh)) {
        scene.add(dentalModel.value.originalMesh);
      }

      // Select the new segment
      segmentManager.selectedSegments.value.forEach((segment) => {
        segment.isSelected = false;
        segmentManager.updateSegmentAppearance(segment);
      });
      segmentManager.selectedSegments.value = [newSegment];
      newSegment.isSelected = true;
      segmentManager.updateSegmentAppearance(newSegment);

      console.log(`Successfully created segment ${newSegment.name}`);
    }
  } catch (error) {
    console.error("Error creating segment:", error);
    alert("Error creating segment. Try selecting a smaller area.");
  } finally {
    threeJSManager.isLoading.value = false;
    threeJSManager.loadingMessage.value = "";
  }
}

function handleLassoSelectSegments(segments: any[]) {
  // Clear current selection
  segmentManager.selectedSegments.value.forEach((segment) => {
    segment.isSelected = false;
    segmentManager.updateSegmentAppearance(segment);
  });

  // Select the lassoed segments
  segmentManager.selectedSegments.value = segments;
  segments.forEach((segment) => {
    segment.isSelected = true;
    segmentManager.updateSegmentAppearance(segment);
  });

  console.log(`Selected ${segments.length} segments via lasso`);
}

function handleLassoAddToSegment(
  selectedVertices: number[],
  targetSegmentId?: string
) {
  if (!targetSegmentId || selectedVertices.length === 0) {
    alert("Please select a segment first to add vertices to it.");
    return;
  }

  const targetSegment = dentalModel.value?.segments.find(
    (s) => s.id === targetSegmentId
  );
  if (!targetSegment) {
    alert("Target segment not found.");
    return;
  }

  geometryManipulation.addVerticesToSegment(
    targetSegment,
    selectedVertices,
    dentalModel.value?.originalMesh,
    THREE
  );
}

function handleLassoSubtractFromSegment(
  selectedVertices: number[],
  targetSegmentId?: string
) {
  if (!targetSegmentId || selectedVertices.length === 0) {
    alert("Please select a segment first to remove vertices from it.");
    return;
  }

  const targetSegment = dentalModel.value?.segments.find(
    (s) => s.id === targetSegmentId
  );
  if (!targetSegment) {
    alert("Target segment not found.");
    return;
  }

  geometryManipulation.removeVerticesFromSegment(
    targetSegment,
    selectedVertices,
    dentalModel.value?.originalMesh,
    THREE
  );
}

// Directional Movement Functions
function startDirectionalMove(
  axis: "Anteroposterior" | "Vertical" | "Transverse",
  direction: number
) {
  const camera = threeJSManager.getCamera();
  if (!camera || !THREE) return;

  directionalMovement.startDirectionalMove(
    axis,
    direction,
    segmentManager.selectedSegments.value,
    camera,
    THREE,
    () => {
      // Update movement history for all selected segments
      segmentManager.selectedSegments.value.forEach(segment => {
        segmentManager.updateSegmentMovementHistory(segment, 'directional');
      });
      
      // Trigger Vue reactivity by reassigning the dentalModel ref
      if (dentalModel.value) {
        dentalModel.value = { ...dentalModel.value };
      }
      
      // Trigger intersection detection after movement
      if (dentalModel.value) {
        segmentManager.detectIntersections(dentalModel.value);
      }
    }
  );
}

function stopDirectionalMove() {
  directionalMovement.stopDirectionalMove();
  
  // Update movement history for all selected segments when movement stops
  segmentManager.selectedSegments.value.forEach(segment => {
    segmentManager.updateSegmentMovementHistory(segment, 'directional');
  });
  
  // Trigger Vue reactivity by reassigning the dentalModel ref
  if (dentalModel.value) {
    dentalModel.value = { ...dentalModel.value };
  }
}

// Segment Management Functions
function toggleOriginalMesh() {
  if (!dentalModel.value) return;
  segmentManager.toggleOriginalMesh(dentalModel.value);
  
  // Trigger Vue reactivity by reassigning the dentalModel ref
  dentalModel.value = { ...dentalModel.value };
}

function toggleAllSegments() {
  if (!dentalModel.value) return;
  segmentManager.toggleAllSegments(dentalModel.value);
  
  // Trigger Vue reactivity by reassigning the dentalModel ref
  dentalModel.value = { ...dentalModel.value };
}

function deleteSegment(segment: any) {
  if (!dentalModel.value) return;
  const scene = threeJSManager.getScene();
  if (!scene) return;

  segmentManager.deleteSegment(segment, scene, dentalModel.value);

  // Trigger Vue reactivity by reassigning the dentalModel ref
  dentalModel.value = { ...dentalModel.value };
  console.log("🔄 Triggered Vue reactivity after deleting segment");
}

// Treatment Plan Handlers
function handlePlanCreated(plan: OrthodonticTreatmentPlan) {
  currentTreatmentPlan.value = plan;
  
  // Store current positions as original positions for progressive movement
  if (dentalModel.value) {
    dentalModel.value.segments.forEach(segment => {
      if (!segment.originalPosition) {
        segment.originalPosition = segment.mesh.position.clone();
      }
    });
  }
  
  console.log("Treatment plan created:", plan);
}

function handlePlanUpdated(plan: OrthodonticTreatmentPlan | null) {
  currentTreatmentPlan.value = plan;
  console.log("Treatment plan updated:", plan);
  
  // If no plan, show all segments
  if (!plan && dentalModel.value) {
    showAllSegments();
  }
}

function showAllSegments() {
  if (!dentalModel.value) {
    return;
  }
  
  // Show all segments and apply their final treatment positions
  if (currentTreatmentPlan.value) {
    // Apply final step positions (last step of treatment)
    const finalStep = currentTreatmentPlan.value.totalSteps;
    dentalModel.value.segments.forEach(segment => {
      segment.mesh.visible = true;
      applyProgressiveMovement(segment, finalStep);
    });
  } else {
    // No treatment plan - just show all segments in current positions
    dentalModel.value.segments.forEach(segment => {
      segment.mesh.visible = true;
    });
  }
  
  // Trigger Vue reactivity
  dentalModel.value = { ...dentalModel.value };
  console.log("All segments shown");
}

function applyProgressiveMovement(segment: any, stepNumber: number) {
  if (!currentTreatmentPlan.value) {
    return;
  }

  // Find the tooth movement data for this segment
  const toothMovement = currentTreatmentPlan.value.teethMovements.find(
    tooth => tooth.toothId === segment.id
  );

  if (!toothMovement) {
    // If no movement data, keep segment in original position
    if (segment.originalPosition) {
      segment.mesh.position.copy(segment.originalPosition);
      segment.mesh.updateMatrixWorld();
    }
    return;
  }

  // Calculate total movement for this step
  let totalMovement = { x: 0, y: 0, z: 0 };

  toothMovement.movements.forEach(movement => {
    const movementStartStep = movement.startStep || toothMovement.startStep || 1;
    const movementDuration = movement.userSteps || movement.recommendedSteps || 1;
    const movementEndStep = movementStartStep + movementDuration - 1;

    // Check if this movement is active in the current step
    if (stepNumber >= movementStartStep && stepNumber <= movementEndStep) {
      // Calculate how many steps into this movement we are
      const stepsIntoMovement = stepNumber - movementStartStep + 1;
      const totalSteps = movementDuration;
      
      // Calculate the proportion of movement completed
      const movementProgress = Math.min(stepsIntoMovement / totalSteps, 1);
      
      // Apply movement based on direction
      const movementDistance = movement.distance * movementProgress;
      
      switch (movement.direction) {
        case 'anteroposterior':
          totalMovement.z += movementDistance;
          break;
        case 'vertical':
          totalMovement.y += movementDistance;
          break;
        case 'transverse':
          totalMovement.x += movementDistance;
          break;
      }
    } else if (stepNumber > movementEndStep) {
      // If we're past the end of this movement, apply the full movement
      switch (movement.direction) {
        case 'anteroposterior':
          totalMovement.z += movement.distance;
          break;
        case 'vertical':
          totalMovement.y += movement.distance;
          break;
        case 'transverse':
          totalMovement.x += movement.distance;
          break;
      }
    }
    // If stepNumber < movementStartStep, no movement is applied (stays at original position)
  });

  // Apply the calculated movement to the segment
  if (segment.originalPosition) {
    segment.mesh.position.set(
      segment.originalPosition.x + totalMovement.x,
      segment.originalPosition.y + totalMovement.y,
      segment.originalPosition.z + totalMovement.z
    );
    segment.mesh.updateMatrixWorld();
  }

  console.log(`Applied progressive movement to ${segment.name} for step ${stepNumber}:`, totalMovement);
}



function handleStepChanged(stepNumber: number) {
  console.log("Treatment step changed to:", stepNumber);
  updateSegmentVisibilityForStep(stepNumber);
}



function updateSegmentVisibilityForStep(stepNumber: number) {
  if (!dentalModel.value || !currentTreatmentPlan.value) {
    return;
  }

  // Apply progressive movement to all segments, keeping them all visible
  dentalModel.value.segments.forEach(segment => {
    // Keep all segments visible
    segment.mesh.visible = true;
    
    // Apply progressive movement based on current step
    applyProgressiveMovement(segment, stepNumber);
    
    console.log(`Applied progressive movement to ${segment.name} for step ${stepNumber}`);
  });
  
  // Trigger Vue reactivity
  dentalModel.value = { ...dentalModel.value };
}



function handleTreatmentPlanFullScreen(isFullScreen: boolean) {
  isTreatmentPlanFullScreen.value = isFullScreen;
}

function dismissBackgroundStatus() {
  backgroundSegmentationStatus.value.isRunning = false;
  backgroundSegmentationStatus.value.message = "";
  backgroundSegmentationStatus.value.progress = undefined;
}

function handleLogout() {
  localStorage.removeItem('authToken')
  localStorage.removeItem('user')
  router.push('/login')
}

function handleLogoClick() {
  router.push('/cases')
}

async function loadExistingSegments() {
  try {
    if (!caseId || !dentalModel.value) {
      console.log("No case ID or dental model available for loading segments");
      return;
    }

    threeJSManager.loadingMessage.value = "Loading existing segments...";
    
    // Get auth token
    const token = localStorage.getItem('authToken');
    if (!token) {
      throw new Error("No authentication token found");
    }

    // Fetch segments from backend
    const response = await fetch(`http://localhost:3001/api/cases/${caseId}/segments`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      if (response.status === 404) {
        console.log("No segments found for this case");
        return;
      }
      throw new Error(`Failed to fetch segments: ${response.statusText}`);
    }

    const segmentsData = await response.json();
    console.log("Segments data loaded:", segmentsData);

    if (segmentsData.segments && segmentsData.segments.length > 0) {
      // Load each segment
      for (const segmentInfo of segmentsData.segments) {
        try {
          // Load segment mesh from backend
          const segmentUrl = `http://localhost:3001/api/cases/${caseId}/segments/${segmentInfo.id}`;
          const segmentMesh = await fileHandlerService?.loadSTLFile(segmentUrl, token);
          
          if (segmentMesh) {
            // Create segment object
            const segment: ToothSegment = {
              id: segmentInfo.id,
              name: segmentInfo.name || `Segment ${segmentInfo.id}`,
              mesh: segmentMesh,
              originalVertices: [], // Will be populated if needed
              centroid: new THREE.Vector3(),
              color: new THREE.Color(segmentInfo.color || 0x00ff00),
              toothType: 'incisor', // Default type, can be updated later
              isSelected: false,
              originalPosition: segmentMesh.position.clone(),
              movementHistory: {
                totalDistance: 0,
                axisMovements: {
                  anteroposterior: 0,
                  vertical: 0,
                  transverse: 0
                },
                movementCount: 0
              }
            };

            // Add to dental model
            dentalModel.value.segments.push(segment);
            
            // Add to scene
            const scene = threeJSManager.getScene();
            if (scene) {
              scene.add(segmentMesh);
            }

            // Apply segment styling
            segmentManager.updateSegmentAppearance(segment);
            
            console.log(`Loaded segment: ${segment.name}`);
          }
        } catch (segmentError) {
          console.error(`Failed to load segment ${segmentInfo.id}:`, segmentError);
        }
      }

      // Trigger Vue reactivity
      dentalModel.value = { ...dentalModel.value };
      
      console.log(`Successfully loaded ${dentalModel.value.segments.length} segments`);
      
      // Detect intersections after loading segments
      segmentManager.detectIntersections(dentalModel.value);
    } else {
      console.log("No segments found for this case");
    }
  } catch (error) {
    console.error("Failed to load existing segments:", error);
  } finally {
    threeJSManager.loadingMessage.value = "";
  }
}

// Intersection Detection Handlers
function handleIntersectionHighlight(intersection: any) {
  console.log("Highlighting intersection:", intersection);
  // TODO: Implement intersection highlighting
}

function handleIntersectionIsolate(intersection: any) {
  console.log("Isolating segments for intersection:", intersection);
  // TODO: Implement segment isolation
}

function handleClearIntersectionVisualizations() {
  segmentManager.clearIntersectionVisualizations();
  console.log("Cleared intersection visualizations");
}

function handleExportIntersectionData() {
  const data = {
    intersections: segmentManager.intersectionResults.value,
    statistics: segmentManager.intersectionStatistics.value,
    timestamp: new Date().toISOString()
  };
  
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `intersection-data-${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
  
  console.log("Exported intersection data");
}

async function initializeEnhancedLasso(renderer: any, camera: any, scene: any) {
  try {
    const { EnhancedLassoService } = await import(
      "../services/EnhancedLassoService"
    );
    enhancedLassoService = new EnhancedLassoService(
      renderer.domElement,
      camera,
      renderer,
      scene
    );
  } catch (error) {
    console.error("Failed to initialize Enhanced Lasso Service:", error);
  }
}

// File handling
async function handleFileUpload(event: Event, autoSegment: boolean = false) {
  console.log("📁 handleFileUpload called with autoSegment:", autoSegment);
   if (!fileHandlerService) {
    console.error("❌ fileHandlerService is not initialized");
    return;
  }

  const onLoadStart = () => {
    threeJSManager.isLoading.value = true;
    threeJSManager.loadingMessage.value = "Loading 3D model...";
  };

  const onLoadComplete = (model: DentalModel) => {
    dentalModel.value = model;
    threeJSManager.focusOnModel(model);
    threeJSManager.isLoading.value = false;
    threeJSManager.loadingMessage.value = "Model loaded successfully";
    
    // Detect intersections after model is loaded
    if (model.segments.length > 0) {
      segmentManager.detectIntersections(model);
    }
  };

  const onError = (error: Error) => {
    alert(error.message);
    threeJSManager.isLoading.value = false;
    threeJSManager.loadingMessage.value = "";
  };

  const startBackgroundAISegmentation = async (file: File) => {
    console.log(
      "🤖 startBackgroundAISegmentation called with file:",
      file.name
    );
    if (!segmentationService) {
      console.error("❌ segmentationService is not initialized");
      return;
    }
    if (!dentalModel.value) {
      console.error("❌ dentalModel is not loaded");
      return;
    }

    await segmentationService.startBackgroundAISegmentation(
      file,
      dentalModel.value,
      (status) => {
        backgroundSegmentationStatus.value = status;
      },
      (result) => {
        console.log(
          `✅ Background AI Segmentation completed: ${result.segments.length} teeth found`
        );
        setTimeout(() => {
          backgroundSegmentationStatus.value.isRunning = false;
          backgroundSegmentationStatus.value.message = "";
          backgroundSegmentationStatus.value.progress = undefined;

          threeJSManager.loadingMessage.value = `AI found ${result.segments.length} teeth!`;
          setTimeout(() => {
            threeJSManager.loadingMessage.value = "";
          }, 3000);
        }, 1000);
      },
      (error) => {
        console.error("Background AI Segmentation failed:", error);
        backgroundSegmentationStatus.value.isRunning = false;
        backgroundSegmentationStatus.value.message = "";
        backgroundSegmentationStatus.value.progress = undefined;

        threeJSManager.loadingMessage.value = `AI segmentation failed: ${error.message}`;
        setTimeout(() => {
          threeJSManager.loadingMessage.value = "";
        }, 5000);
      },
      (updatedDentalModel) => {
        // Update the reactive dentalModel ref to trigger Vue reactivity
        dentalModel.value = updatedDentalModel;
        console.log(
          "🔄 Updated dentalModel ref to trigger Vue reactivity and sidebar update"
        );
      }
    );
  };

  console.log(
    "📤 Calling fileHandlerService.handleFileUpload with autoSegment:",
    autoSegment
  );
  await fileHandlerService.handleFileUpload(
    event,
    autoSegment,
    onLoadStart,
    onLoadComplete,
    onError,
    startBackgroundAISegmentation
  );
}
</script>

<style scoped>
.dental-viewer {
  display: flex;
  flex-direction: column;
  height: 100vh;
  width: 100vw;
  background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
  color: #f1f5f9;
  font-family: "Inter", "SF Pro Display", -apple-system, BlinkMacSystemFont,
    sans-serif;
  overflow: hidden;
}

.main-content {
  display: flex;
  flex: 1;
  overflow: hidden;
  height: calc(100vh - 64px); /* Account for header height */
}

.main-content.treatment-fullscreen {
  display: none;
}

.fullscreen-treatment-plan {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 1000;
  background: rgba(0, 0, 0, 0.02);
  backdrop-filter: blur(2px);
  animation: fadeInBackdrop 0.3s ease;
  display: flex;
  flex-direction: column;
}

@keyframes fadeInBackdrop {
  from {
    opacity: 0;
    backdrop-filter: blur(0px);
  }
  to {
    opacity: 1;
    backdrop-filter: blur(2px);
  }
}

@media (max-width: 768px) {
  .main-content {
    flex-direction: column;
  }
}

.user-info {
  display: flex;
  align-items: center;
  gap: 16px;
}

.logout-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
  border: 1px solid rgba(239, 68, 68, 0.3);
  color: white;
  padding: 10px 16px;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  font-size: 14px;
  font-weight: 600;
  backdrop-filter: blur(8px);
  position: relative;
  overflow: hidden;
  box-shadow: 0 2px 8px rgba(239, 68, 68, 0.2);
}

.logout-btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
  transition: left 0.6s ease;
}

.logout-btn:hover::before {
  left: 100%;
}

.logout-btn:hover {
  background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
  border-color: rgba(239, 68, 68, 0.5);
  transform: translateY(-1px);
  box-shadow: 0 4px 16px rgba(239, 68, 68, 0.3);
}
</style>
